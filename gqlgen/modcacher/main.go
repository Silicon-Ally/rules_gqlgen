// Command modcacher currently just takes in a go.mod file and a source tree
// generated by a Bazel go_path rule and strips the go.mod file down to the
// dependencies in the source tree. In the future, it'll be extended to
// generate a full module cache that can be used to build the gqlgen binary.
package main

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"

	"golang.org/x/mod/modfile"
)

func main() {
	goModPath, goSrcRoot := os.Args[1], os.Args[2]
	dat, err := ioutil.ReadFile(goModPath)
	if err != nil {
		log.Fatalf("failed to read go mod file: %v", err)
	}

	f, err := modfile.Parse(goModPath, dat, nil)
	if err != nil {
		log.Fatalf("failed to parse go mod file: %v", err)
	}

	for _, req := range f.Require {
		_, err = os.Stat(filepath.Join(goSrcRoot, req.Mod.Path))
		if os.IsNotExist(err) {
			if err := f.DropRequire(req.Mod.Path); err != nil {
				log.Fatalf("failed to drop require %q: %v", req.Mod.Path, err)
			}
			continue
		}
		if err != nil {
			log.Fatalf("error stat-ing directory: %v", err)
		}
	}

	// Write the new go.mod file.
	newDat, err := f.Format()
	if err != nil {
		log.Fatalf("failed to format new go.mod file: %v", err)
	}
	if err := ioutil.WriteFile(goModPath, newDat, 0777); err != nil {
		log.Fatalf("failed to write new go.mod file: %v", err)
	}
}
