# Example Usage

This minimal example demonstrates the functionality of the `gqlgen` build rule.

To run this you'll need to have [Bazel](https://bazel.build/) installed,
and it's also recommended to use [Bazelisk](https://github.com/bazelbuild/bazelisk)
to choose a suitable version of bazel to run. We use [Gazelle](https://github.com/bazelbuild/bazel-gazelle)
to manage Go dependencies in bazel, but that isn't strictly nescessary.

## What is happening? 

The input to the build rule is the `schema.graphqls`, which describes the
queries and mutations that your GraphQL server is going to serve to clients.
The format of the GraphQL schema file is described in
[the official GraphQL docs](https://graphql.org/learn/).

When the rule executes, a [gqlgen.yml](https://gqlgen.com/config/) file is generated, the `gqlgen` code generator tool is run, and two
separate Go libraries are produced, `model` and `generated`.

The `model` library consists of `bazel-bin/example/model/models_gen.go`, which
contains the Go structs that mirror the types expressed in your GraphQL schema.
This allows you to write business logic that uses types defined in your schema.

```golang
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

type Greeting struct {
	Message string `json:"message"`
	Lang    string `json:"lang"`
}

type UpdateGreetingRequest struct {
	Name string `json:"name"`
}
```

The `generated` library consists of `bazel-bin/example/generated/generated.go`,
which contains a generated GraphQL server runtime that can serve your API,
usually over HTTP and/or WebSockets. It handles deserializing and validating
the incoming requests, then calling the correct resolvers, which you'll
implement. For this example, the interface to implement looks like:

```go
type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type MutationResolver interface {
	UpdateName(ctx context.Context, req model.UpdateGreetingRequest) (*bool, error)
}
type QueryResolver interface {
	Greetings(ctx context.Context) ([]*model.Greeting, error)
}
```

Take a look at [main.go](/example/main.go) to see what a basic `Resolver`
implementation looks like. Then, you can instantiate your server like:

```
import (
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/Silicon-Ally/rules_gqlgen/example/generated"
)

// ... more setup code ... 
srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &Resolver{}}))
// ... srv implements http.Handler and can now be used, e.g. via http.ListenAndServe  ...
```

## Playground

When you run the example server, it runs on port 8080, and you can access the
playground at `http://localhost:8080/api/playground`. To test the example query
and mutation:

```graphql
# Query greetings
{
  greetings {
    message
    lang
  }
}

# Set a name
mutation {
  updateName(req:{name:"Moxie"})
}
```
